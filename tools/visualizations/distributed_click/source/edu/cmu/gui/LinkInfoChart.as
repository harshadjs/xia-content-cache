package edu.cmu.gui {		import flash.display.MovieClip;	import flash.display.Shape;	import flash.utils.Dictionary;	import flash.text.TextFormat;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import edu.cmu.MyGlobal;	//[Embed(source='Arial.ttf', fontName='fontArial', mimeType='application/x-font')]		public class LinkInfoChart extends LinkInfoBase {				// Constants:		const WIDTH:int = 150;		const HEIGHT:int = 90;		const N:int = 20; // how many previous points to remember		const FOREGROUND_COLOR:uint = 0xFFFFFF;  // color for axes and text		const PADDING_BOTTOM:int = 25;  // space between X axis and bottom of box		const PADDING_LEFT:int = 35;  // space between Y axis and left of box		const PADDING_TOP:int = 5;		const PADDING_RIGHT:int = 10;				//[Embed(source="/Library/Fonts/Arial Unicode.ttf", fontFamily="Arial")]		//private var _arial_str:String;		// Public Properties:		// Private Properties:		private var dataPoints:Vector.<Dictionary>;		private var maxRate:int;		// UI Elements:		private var yMax:TextField;		private var yMid:TextField;		private var yMin:TextField;		private var linesByType:Dictionary;								// Initialization:		public function LinkInfoChart() {			dataPoints = new Vector.<Dictionary>();			linesByType = new Dictionary();			maxRate = 0;			configUI();		}		// Public Methods:		public override function updateCurrentTraffic(currentTrafficByType:Dictionary):void {			dataPoints.push(currentTrafficByType);						// See if any of the new rates is our new max			for each (var rate:int in currentTrafficByType) {				if (rate > maxRate) {					maxRate = rate;				}			}									// Remove old data points			var needNewMax:Boolean = false;			while (dataPoints.length > N) {				var oldRates:Dictionary = dataPoints.shift();								// See if this dictionary contains our max				for each (var rate:int in oldRates) {					if (rate == maxRate) {						needNewMax = true;						break;					}				}			}						// Find a new max rate, if necessary			if (needNewMax) {				maxRate = 0;				for each (var rates:Dictionary in dataPoints) {					for each (var rate:int in rates) {						if (rate > maxRate) {							maxRate = rate;						}					}				}			}						drawData();		}						// Protected Methods:		// Private Methods:				protected function drawData():void {			// Adjust Y axis labels			setYAxisLabels();						// Remove existing lines (if any)			for each (var line:Shape in linesByType) {				if (this.contains(line)) {					this.removeChild(line);				}			}						// Make a new dictionary for new lines			linesByType = new Dictionary();						// Set up the lines			// TODO: If we later encounter a type not in the first dictionary, it will be ignored			for (var type:String in dataPoints[0]) {				var line:Shape = new Shape();				line.graphics.lineStyle(1, MyGlobal.getColorForPrincipal(type), 1);				line.graphics.moveTo(PADDING_LEFT, YCoordForValue(dataPoints[0][type]));								linesByType[type] = line;			}						// Draw lines			var xIncr:int = (WIDTH-PADDING_LEFT-PADDING_RIGHT) / N;			var x:int = PADDING_LEFT;			for each (var rates:Dictionary in dataPoints) {				for (var type:String in rates) {					linesByType[type].graphics.lineTo(x, YCoordForValue(rates[type]));				}								x += xIncr;			}						// Add lines to stage			for each (var line:Shape in linesByType) {				this.addChild(line);			}		}				protected function YCoordForValue(rate:int):int {			var yRelToXAxis:int = int(Number(rate)/Number(maxRate)*(HEIGHT-PADDING_TOP-PADDING_BOTTOM));			return HEIGHT - PADDING_BOTTOM - yRelToXAxis;		}				protected function YMax():int {			// For now, the max Y value is the nearest number			// divisible by 10 greater than or equal to maxRate			return (Math.ceil(maxRate / 10)) * 10;		}				protected function setYAxisLabels():void {						// yMin is always 0, so don't worry about it						yMax.text = String(YMax());			yMax.x = PADDING_LEFT - yMax.width - 1;			yMax.y = PADDING_TOP - 2;						yMid.text = String(YMax() / 2);			yMid.x = PADDING_LEFT - yMid.width - 1;			yMid.y = yMax.y + (yMin.y - yMax.y) / 2;		}				protected override function configUI():void {			this.getChildAt(0).height = HEIGHT;			this.getChildAt(0).width = WIDTH;						// Draw X Axis			var xAxis:Shape = new Shape();			xAxis.graphics.lineStyle(2, FOREGROUND_COLOR, 1);			xAxis.graphics.moveTo(PADDING_LEFT, HEIGHT - PADDING_BOTTOM);			xAxis.graphics.lineTo(WIDTH - PADDING_RIGHT, HEIGHT - PADDING_BOTTOM);			this.addChild(xAxis);						// Label X Axis			var xLabel:TextField = MyGlobal.makeLabel("Time", FOREGROUND_COLOR, 12, true);			xLabel.x = PADDING_LEFT + (WIDTH-PADDING_RIGHT-PADDING_LEFT-xLabel.width)/2;			xLabel.y = HEIGHT - PADDING_BOTTOM;			this.addChild(xLabel);						// Draw Y Axis			var yAxis:Shape = new Shape();			yAxis.graphics.lineStyle(2, FOREGROUND_COLOR, 1);			yAxis.graphics.moveTo(PADDING_LEFT, PADDING_TOP);			yAxis.graphics.lineTo(PADDING_LEFT, HEIGHT - PADDING_BOTTOM);			this.addChild(yAxis);						//// Label Y Axis//			var yLabel:TextField = makeEmbeddedLabel("Pkts/sec", FOREGROUND_COLOR, 12, true);//			//yLabel.rotation = 90;//			yLabel.x = 20;//			yLabel.y = 40;//			this.addChild(yLabel);						yMax = MyGlobal.makeLabel("10", FOREGROUND_COLOR);			yMax.x = PADDING_LEFT - yMax.width - 1;			yMax.y = PADDING_TOP - 2;			this.addChild(yMax);			yMin = MyGlobal.makeLabel("0", FOREGROUND_COLOR);			yMin.x = PADDING_LEFT - yMin.width - 1;			yMin.y = HEIGHT-PADDING_BOTTOM-yMin.height+2;			this.addChild(yMin);			yMid = MyGlobal.makeLabel("5", FOREGROUND_COLOR);			yMid.x = PADDING_LEFT - yMid.width - 1;			yMid.y = yMax.y + (yMin.y - yMax.y) / 2;			this.addChild(yMid);						// Draw background of quadrant			var bgRect:Shape = new Shape;			bgRect.graphics.beginFill(FOREGROUND_COLOR, 0.3);			bgRect.graphics.drawRect(PADDING_LEFT, PADDING_TOP, WIDTH-PADDING_RIGHT-PADDING_LEFT, HEIGHT-PADDING_TOP-PADDING_BOTTOM); // (x spacing, y spacing, width, height)			bgRect.graphics.endFill();			this.addChild(bgRect);		}						//private function makeEmbeddedLabel(text:String, color:uint, size:uint = 11, bold:Boolean = false):TextField {//			var textFormat:TextFormat = new TextFormat(); //("ArialEmbedded", size, color); //			textFormat.font = "fontArial";//			textFormat.size = size;//			textFormat.bold = bold;//			//			var label:TextField = new TextField();			//			label.text = text;//			label.embedFonts = true;//			label.setTextFormat(textFormat);//			//label.defaultTextFormat = textFormat;//			//label.autoSize = TextFieldAutoSize.LEFT;//			//label.textColor = color;//			//			return label;//		}	}	}